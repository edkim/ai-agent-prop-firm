# Knowledge Extraction Implementation Plan

## Overview
The learning system is ready for knowledge extraction. All prerequisites are in place, and there's a clear gap where learned insights should be captured and reused.

## Critical Gap Identified

### Current Situation
- ExpertAnalysis is generated by Claude after each iteration (✓ exists)
- Refinements are proposed from the analysis (✓ exists)  
- Refinements are approved automatically based on thresholds (✓ exists)
- New strategy versions are created from approved refinements (✓ exists)
- **agent_knowledge table exists but is NEVER populated** (✗ missing)

### The Problem
When a refinement is approved and applied, the learning it represents is lost. There's no mechanism to:
1. Extract actionable knowledge from the analysis
2. Store it for future iterations to reference
3. Track when that knowledge proves correct (validation)
4. Use it to guide subsequent strategy generations

## Implementation Strategy

### Phase 1: Knowledge Extraction Service (Core)
Create a new service: `agent-knowledge-extraction.service.ts`

**Responsibility**: Convert ExpertAnalysis into AgentKnowledge entries

**Key Methods**:
1. `extractKnowledge(analysis: ExpertAnalysis, iterationNumber: number): KnowledgeItem[]`
   - Maps analysis components to knowledge types
   - Assigns confidence scores
   - Generates human-readable insights

2. `storeKnowledge(agentId: string, knowledge: KnowledgeItem[]): Promise<void>`
   - Inserts into agent_knowledge table
   - Deduplicates existing similar knowledge
   - Updates confidence scores for repeat findings

3. `getAgentKnowledge(agentId: string, includeUnvalidated: boolean): Promise<AgentKnowledge[]>`
   - Retrieves knowledge for strategy generation
   - Optional filtering for mature knowledge only

### Phase 2: Integration Points

#### 1. Post-Analysis (agent-learning.service.ts)
**Location**: After `analyzeResults()` call, in `runIteration()`

```typescript
// After: const analysis = await this.analyzeResults(...)
const knowledge = await this.knowledgeExtraction.extractKnowledge(
  analysis,
  iterationNumber
);
await this.knowledgeExtraction.storeKnowledge(agentId, knowledge);
```

**Benefit**: Captures insights immediately while fresh

#### 2. Post-Approval (refinement-approval.service.ts)
**Location**: After successful approval in `evaluateAndApply()`

```typescript
// After: await this.getLearningService().applyRefinements(...)
// NEW: Validate and strengthen knowledge from approved refinements
const extractedKnowledge = await this.knowledgeExtraction
  .validateApprovedKnowledge(agentId, iterationId, approvalResult);
```

**Benefit**: Marks knowledge as validated, increases confidence

#### 3. Performance Analysis (performance-monitor.service.ts)
**Location**: When storing alerts in `analyzeIteration()`

```typescript
// After each alert creation:
if (alert.alert_type === 'CONVERGENCE') {
  // Knowledge has stabilized - mark mature
  await this.knowledgeExtraction.markKnowledgeMature(agentId);
}

if (alert.alert_type === 'PERFORMANCE_DEGRADATION') {
  // Reduce confidence in recent knowledge
  await this.knowledgeExtraction.reduceKnowledgeConfidence(agentId);
}
```

**Benefit**: Adjusts confidence based on performance signals

#### 4. Strategy Generation (agent-learning.service.ts)
**Location**: In `generateStrategy()`, before Claude calls

```typescript
// Existing code (lines 137-139)
const knowledge = await this.getAgentKnowledge(agent.id);
const knowledgeSummary = this.formatKnowledgeSummary(knowledge);

// NEW: Enhance formatting with knowledge types
const knowledgeSummary = this.knowledgeExtraction
  .formatKnowledgeForStrategyGeneration(knowledge, agent.pattern_focus);
```

**Benefit**: Reuses extracted learning to improve next iteration

### Phase 3: Knowledge Validation Lifecycle

#### When Knowledge is Used Successfully
```typescript
// In applyRefinements() or runIteration():
if (iterationApproved && refinement.knowledgeId) {
  db.prepare(`
    UPDATE agent_knowledge
    SET times_validated = times_validated + 1,
        last_validated = ?
    WHERE id = ?
  `).run(new Date().toISOString(), refinement.knowledgeId);
}
```

#### When Knowledge Fails
```typescript
// In checkPerformanceDegradation():
// If iteration used knowledge X but degraded significantly:
db.prepare(`
  UPDATE agent_knowledge
  SET confidence = confidence * 0.9  -- Reduce confidence
  WHERE id = ?
`).run(knowledgeId);
```

#### Maturation Markers
```typescript
// In checkConvergence():
if (performanceHasConverged) {
  db.prepare(`
    UPDATE agent_knowledge
    SET status = 'MATURE'
    WHERE agent_id = ? AND times_validated >= 3
  `).run(agentId);
}
```

## Data Mappings (Detailed)

### 1. Parameter Recommendations → PARAMETER_PREF

**Input**:
```typescript
parameter_recommendations: [
  {
    parameter: "Stop Loss %",
    currentValue: 0.01,
    recommendedValue: 0.02,
    expectedImprovement: "Reduces whipsaw exits by 30%"
  }
]
```

**Output**:
```typescript
AgentKnowledge {
  id: uuid(),
  agent_id: "agent-123",
  knowledge_type: "PARAMETER_PREF",
  pattern_type: agent.pattern_focus[0], // e.g., "vwap_bounce"
  insight: "Stop loss of 2% performs better than 1% for this pattern",
  supporting_data: JSON.stringify({
    parameter: "Stop Loss %",
    range_tested: [0.01, 0.015, 0.02],
    best_value: 0.02,
    improvement_estimate: "Reduces whipsaw exits by 30%",
    applicable_to: ["vwap_bounce", "gap_fill"]
  }),
  confidence: 0.85, // From analysis.projected_performance.confidence
  learned_from_iteration: 5,
  times_validated: 0,
  created_at: timestamp
}
```

### 2. Working Elements → PATTERN_RULE

**Input**:
```typescript
working_elements: [
  {
    element: "VWAP bounce detection is reliable",
    evidence: "Bounces off VWAP with volume confirmation identified 12 winning trades",
    confidence: 0.93
  }
]
```

**Output**:
```typescript
AgentKnowledge {
  id: uuid(),
  agent_id: "agent-123",
  knowledge_type: "PATTERN_RULE",
  pattern_type: "vwap_bounce",
  insight: "VWAP bounces with volume confirmation create high-confidence entry signals",
  supporting_data: JSON.stringify({
    signal_type: "VWAP bounce",
    entry_confirmation: "Volume spike > 1.2x average",
    win_rate_observed: 0.75, // 12 wins / 16 trades
    exit_rule: "Time or 2% profit target",
    context: "Works best in trending market conditions",
    tested_iterations: [4, 5]
  }),
  confidence: 0.93,
  learned_from_iteration: 5,
  times_validated: 0,
  created_at: timestamp
}
```

### 3. Failure Points → PATTERN_RULE (Negative)

**Input**:
```typescript
failure_points: [
  {
    issue: "Entry after market open missed best moves",
    evidence: "Trades entered after 10:00 AM averaged 30% lower returns",
    impact: "Reduces strategy profitability by 25%",
    suggestedFix: "Prioritize entries in first 2 hours of trading"
  }
]
```

**Output**:
```typescript
AgentKnowledge {
  id: uuid(),
  agent_id: "agent-123",
  knowledge_type: "PATTERN_RULE",
  pattern_type: null, // General timing rule
  insight: "Entries after 10:00 AM result in 30% lower returns",
  supporting_data: JSON.stringify({
    constraint: "Time of day",
    best_time_window: "09:30 - 10:30 AM",
    impact_if_violated: "-25% profitability",
    evidence: "Trades after 10:00 AM averaged 30% lower returns",
    trades_analyzed: 45,
    recommendation: "Prioritize entries in first 2 hours of trading",
    exception: "Earnings announcement days may have different patterns"
  }),
  confidence: 0.75, // Lower due to evidence of exceptions
  learned_from_iteration: 5,
  times_validated: 0,
  created_at: timestamp
}
```

### 4. Missing Context → INSIGHT

**Input**:
```typescript
missing_context: [
  {
    dataType: "Support/Resistance levels",
    reasoning: "Would provide better exit targets",
    recommendation: "Add daily support/resistance calculation"
  }
]
```

**Output**:
```typescript
AgentKnowledge {
  id: uuid(),
  agent_id: "agent-123",
  knowledge_type: "INSIGHT",
  pattern_type: null,
  insight: "Adding support/resistance levels would improve exit targeting by 15-20%",
  supporting_data: JSON.stringify({
    missing_data: "Support/Resistance levels",
    estimated_impact: "Reduces exit error by 15-20%",
    implementation_effort: "Medium - requires daily level calculation",
    priority: "Medium - should implement in next 2-3 iterations",
    rationale: "Exit targeting is source of profit loss in backtest analysis"
  }),
  confidence: 0.60, // Lower - not yet implemented/validated
  learned_from_iteration: 5,
  times_validated: 0,
  created_at: timestamp
}
```

## Implementation Checklist

### Core Service
- [ ] Create `agent-knowledge-extraction.service.ts`
- [ ] Implement `extractKnowledge()` method with all 4 mappings
- [ ] Implement `storeKnowledge()` with deduplication logic
- [ ] Add confidence calculation logic
- [ ] Unit tests for mappings

### Integration Points
- [ ] Add extraction call in `agent-learning.service.ts` after analysis
- [ ] Add validation call in `refinement-approval.service.ts` after approval
- [ ] Add confidence adjustment in `performance-monitor.service.ts`
- [ ] Update strategy generation to use knowledge
- [ ] Tests for each integration point

### Knowledge Lifecycle
- [ ] Implement `markKnowledgeMature()` method
- [ ] Implement `reduceKnowledgeConfidence()` method
- [ ] Implement validation tracking on reuse
- [ ] Add confidence decay for old knowledge (optional)

### Data Integrity
- [ ] Deduplication logic (avoid duplicate insights)
- [ ] Confidence score normalization
- [ ] Orphaned knowledge cleanup
- [ ] Data migration for existing iterations

### Monitoring & Observability
- [ ] Log knowledge creation with details
- [ ] Track knowledge reuse statistics
- [ ] Monitor confidence score distribution
- [ ] Alert on low-confidence knowledge being used

## Success Metrics

1. **Knowledge Capture**: Every iteration generates 3-5 knowledge items
2. **Knowledge Reuse**: Strategy generation references accumulated knowledge
3. **Validation**: Knowledge used in approved refinements shows improved performance
4. **Maturation**: Knowledge items accumulate validation cycles (target: 5+ validations)
5. **Impact**: Agents reach graduation criteria faster using accumulated knowledge

## Risk Mitigation

### Risk: Incorrect knowledge capture
**Mitigation**: Low initial confidence scores (0.6-0.75), require 3+ validations for "mature" status

### Risk: Conflicting knowledge items
**Mitigation**: Deduplication logic, manual conflict resolution via UI, confidence weighting

### Risk: Knowledge staleness
**Mitigation**: Track `last_validated` date, weight recent knowledge higher, decay old knowledge

### Risk: Over-reliance on flawed learnings
**Mitigation**: Agent can still graduate even with imperfect knowledge, continuous iteration

## Next Steps

1. **Design Review**: Share mapping examples with team
2. **Service Implementation**: Build knowledge extraction service
3. **Integration Testing**: Test full pipeline with real agent runs
4. **UI Enhancement**: Show accumulated knowledge in agent dashboard
5. **Performance Analysis**: Measure impact on convergence speed
