/**
 * Opening Range Breakout Backtest - Template
 *
 * This template is dynamically generated by ScriptGeneratorService
 * Template variables (replaced at generation time):
 * - {{TICKER}} - Stock ticker symbol
 * - {{DATE}} - Backtest date (YYYY-MM-DD)
 * - {{TIMEFRAME}} - Bar timeframe (default: 5min)
 * - {{TRAILING_STOP_PCT}} - Trailing stop percentage
 * - {{MARKET_FILTER_TICKER}} - Market filter ticker (optional)
 */

import { initializeDatabase, getDatabase } from './src/database/db';
import dotenv from 'dotenv';

dotenv.config();

interface Bar {
  timestamp: number;
  open: number;
  high: number;
  low: number;
  close: number;
  volume: number;
  timeOfDay: string;
}

interface BacktestConfig {
  ticker: string;
  date: string;
  timeframe: string;
  trailingStopPct: number;
  marketFilterTicker?: string;
}

async function runORBBacktest() {
  const dbPath = process.env.DATABASE_PATH || './backtesting.db';
  initializeDatabase(dbPath);

  const db = getDatabase();

  // Configuration (replaced by template generator)
  const config: BacktestConfig = {
    ticker: 'TEMPLATE_TICKER',
    date: 'TEMPLATE_DATE',
    timeframe: 'TEMPLATE_TIMEFRAME',
    trailingStopPct: 2.0,
    marketFilterTicker: undefined,
  };

  console.log('='.repeat(60));
  console.log('OPENING RANGE BREAKOUT BACKTEST');
  console.log('='.repeat(60));
  console.log(`Ticker: ${config.ticker}`);
  console.log(`Date: ${config.date}`);
  console.log(`Strategy: 5-minute opening range breakout`);
  console.log(`Trailing Stop: ${config.trailingStopPct}%`);
  if (config.marketFilterTicker) {
    console.log(`Market Filter: ${config.marketFilterTicker}`);
  }
  console.log('='.repeat(60));
  console.log('');

  // Date range
  const dateStart = new Date(`${config.date}T00:00:00Z`).getTime();
  const dateEnd = new Date(`${config.date}T23:59:59Z`).getTime() + 86400000;

  // Fetch ticker data
  const tickerQuery = `
    SELECT timestamp, open, high, low, close, volume, time_of_day as timeOfDay
    FROM ohlcv_data
    WHERE ticker = ? AND timeframe = ? AND timestamp >= ? AND timestamp < ?
    ORDER BY timestamp ASC
  `;
  const tickerBars = db.prepare(tickerQuery).all(
    config.ticker,
    config.timeframe,
    dateStart,
    dateEnd
  ) as Bar[];

  if (tickerBars.length === 0) {
    console.log(`‚ùå No ${config.ticker} data found!`);
    process.exit(1);
  }

  console.log(`üìä ${config.ticker} bars loaded: ${tickerBars.length}`);

  // Fetch market filter data if specified
  let filterBars: Bar[] = [];
  if (config.marketFilterTicker) {
    filterBars = db.prepare(tickerQuery).all(
      config.marketFilterTicker,
      config.timeframe,
      dateStart,
      dateEnd
    ) as Bar[];

    if (filterBars.length === 0) {
      console.log(`‚ö†Ô∏è  No ${config.marketFilterTicker} data found, proceeding without filter`);
    } else {
      console.log(`üìä ${config.marketFilterTicker} bars loaded: ${filterBars.length}`);
    }
  }

  console.log('');

  // Find opening range bar (9:30 AM)
  let openingRangeIndex = tickerBars.findIndex(bar => {
    const time = bar.timeOfDay;
    return time === '09:30' || time === '13:30';
  });

  if (openingRangeIndex === -1) {
    console.log('‚ùå Could not find opening bar (9:30 AM)');
    process.exit(1);
  }

  const openingBar = tickerBars[openingRangeIndex];
  const openingRangeHigh = openingBar.high;
  const openingRangeLow = openingBar.low;

  console.log('üìà OPENING RANGE (9:30-9:35 AM):');
  console.log(`   Time: ${openingBar.timeOfDay}`);
  console.log(`   Open: $${openingBar.open.toFixed(2)}`);
  console.log(`   High: $${openingRangeHigh.toFixed(2)}`);
  console.log(`   Low: $${openingRangeLow.toFixed(2)}`);
  console.log(`   Close: $${openingBar.close.toFixed(2)}`);
  console.log(`   Range: $${(openingRangeHigh - openingRangeLow).toFixed(2)}`);
  console.log('');

  // Find opening bar for market filter
  let filterOpeningBar: Bar | undefined;
  if (filterBars.length > 0) {
    filterOpeningBar = filterBars.find(bar =>
      bar.timeOfDay === '09:30' || bar.timeOfDay === '13:30'
    );
  }

  // Track position
  let position: { entry: number; entryTime: string; entryBar: Bar; highestPrice: number } | null = null;
  let entryIndex = -1;
  let exitBar: Bar | null = null;
  let exitReason = '';

  // Find market close bar index
  const marketCloseIndex = tickerBars.findIndex(bar =>
    bar.timeOfDay === '16:00' || bar.timeOfDay === '20:00'
  );
  const endIndex = marketCloseIndex !== -1 ? marketCloseIndex : tickerBars.length - 1;

  console.log(`‚è∞ Starting breakout detection from bar ${openingRangeIndex + 1}`);
  console.log('');

  // Look for breakout after opening range
  for (let i = openingRangeIndex + 1; i <= endIndex; i++) {
    const bar = tickerBars[i];

    // Entry logic
    if (!position && bar.high > openingRangeHigh) {
      // Check market filter if enabled
      let marketFilterPassed = true;
      if (config.marketFilterTicker && filterBars.length > 0 && filterOpeningBar) {
        const filterBar = filterBars.find(fb => fb.timestamp === bar.timestamp);
        if (filterBar) {
          marketFilterPassed = filterBar.close > filterOpeningBar.open;
          if (!marketFilterPassed) {
            console.log(`‚ö†Ô∏è  Breakout at ${bar.timeOfDay} but ${config.marketFilterTicker} filter not met`);
          }
        }
      }

      if (marketFilterPassed) {
        console.log(`üöÄ BREAKOUT at ${bar.timeOfDay}:`);
        console.log(`   ${config.ticker} broke above $${openingRangeHigh.toFixed(2)}`);
        console.log(`   Bar: O=$${bar.open.toFixed(2)} H=$${bar.high.toFixed(2)} L=$${bar.low.toFixed(2)} C=$${bar.close.toFixed(2)}`);
        if (config.marketFilterTicker) {
          console.log(`   ${config.marketFilterTicker} filter: ‚úÖ PASSED`);
        }
        console.log('');

        // Enter position at close of breakout bar
        position = {
          entry: bar.close,
          entryTime: bar.timeOfDay,
          entryBar: bar,
          highestPrice: bar.high,
        };
        entryIndex = i;
        console.log(`‚úÖ ENTERED LONG at $${position.entry.toFixed(2)} (${position.entryTime})`);
        console.log(`   Trailing stop: ${config.trailingStopPct}% from highest price`);
        console.log('');
        continue;
      }
    }

    // Exit logic - trailing stop
    if (position) {
      // Update highest price if new high is made
      if (bar.high > position.highestPrice) {
        const oldHigh = position.highestPrice;
        position.highestPrice = bar.high;
        const newStopPrice = position.highestPrice * (1 - config.trailingStopPct / 100);
        console.log(`üìà NEW HIGH at ${bar.timeOfDay}: $${bar.high.toFixed(2)} (was $${oldHigh.toFixed(2)})`);
        console.log(`   Trailing stop moved to: $${newStopPrice.toFixed(2)}`);
      }

      // Calculate trailing stop level
      const trailingStopPrice = position.highestPrice * (1 - config.trailingStopPct / 100);

      // Check if trailing stop is hit
      if (bar.low <= trailingStopPrice) {
        exitBar = bar;
        exitReason = 'Trailing stop hit';
        console.log('');
        console.log(`üõë TRAILING STOP HIT at ${bar.timeOfDay}:`);
        console.log(`   Bar low: $${bar.low.toFixed(2)}`);
        console.log(`   Stop level: $${trailingStopPrice.toFixed(2)}`);
        console.log(`   Highest price achieved: $${position.highestPrice.toFixed(2)}`);
        console.log(`   Exit price (stop): $${trailingStopPrice.toFixed(2)}`);
        break;
      }
    }
  }

  // If position still open, exit at market close
  if (position && !exitBar) {
    exitBar = tickerBars[endIndex];
    exitReason = 'Market close (4:00 PM)';
  }

  // Calculate results
  if (position && exitBar) {
    const exitPrice = exitReason === 'Trailing stop hit'
      ? position.highestPrice * (1 - config.trailingStopPct / 100)
      : exitBar.close;
    const exitTime = exitBar.timeOfDay;

    const profitLoss = exitPrice - position.entry;
    const profitLossPct = (profitLoss / position.entry) * 100;

    console.log('');
    console.log('üì§ EXIT:');
    console.log(`   Time: ${exitTime}`);
    console.log(`   Reason: ${exitReason}`);
    console.log(`   Exit price: $${exitPrice.toFixed(2)}`);
    console.log('');

    console.log('='.repeat(60));
    console.log('TRADE RESULTS:');
    console.log('='.repeat(60));
    console.log(`Entry: $${position.entry.toFixed(2)} at ${position.entryTime}`);
    console.log(`Exit: $${exitPrice.toFixed(2)} at ${exitTime}`);
    console.log(`Highest price: $${position.highestPrice.toFixed(2)} (+${((position.highestPrice - position.entry) / position.entry * 100).toFixed(2)}%)`);
    console.log(`P&L: $${profitLoss.toFixed(2)} (${profitLossPct > 0 ? '+' : ''}${profitLossPct.toFixed(2)}%)`);
    console.log(`Outcome: ${profitLoss > 0 ? '‚úÖ WINNER' : profitLoss < 0 ? '‚ùå LOSER' : '‚ö™ BREAKEVEN'}`);
    console.log('');

    // Calculate MFE and MAE
    let maxGain = 0;
    let maxLoss = 0;
    let maxGainTime = '';
    let maxLossTime = '';

    for (let i = entryIndex; i <= endIndex; i++) {
      const bar = tickerBars[i];
      const gain = bar.high - position.entry;
      const loss = bar.low - position.entry;

      if (gain > maxGain) {
        maxGain = gain;
        maxGainTime = bar.timeOfDay;
      }
      if (loss < maxLoss) {
        maxLoss = loss;
        maxLossTime = bar.timeOfDay;
      }
    }

    console.log('PERFORMANCE METRICS:');
    console.log(`Exit reason: ${exitReason}`);
    console.log(`Max Favorable Excursion: +$${maxGain.toFixed(2)} (+${((maxGain / position.entry) * 100).toFixed(2)}%) at ${maxGainTime}`);
    console.log(`Max Adverse Excursion: $${maxLoss.toFixed(2)} (${((maxLoss / position.entry) * 100).toFixed(2)}%) at ${maxLossTime}`);
    console.log(`Profit capture: ${((profitLoss / maxGain) * 100).toFixed(2)}% of MFE`);
    console.log('='.repeat(60));

    // Output JSON for easy parsing (optional)
    const jsonOutput = {
      backtest: {
        ticker: config.ticker,
        date: config.date,
        strategy: 'Opening Range Breakout',
        config: config,
      },
      trades: [{
        entry_time: position.entryTime,
        entry_price: position.entry,
        exit_time: exitTime,
        exit_price: exitPrice,
        pnl: profitLoss,
        pnl_percent: profitLossPct,
        exit_reason: exitReason,
        highest_price: position.highestPrice,
        max_gain: maxGain,
        max_loss: maxLoss,
      }],
      metrics: {
        total_trades: 1,
        winning_trades: profitLoss > 0 ? 1 : 0,
        losing_trades: profitLoss < 0 ? 1 : 0,
        win_rate: profitLoss > 0 ? 100 : 0,
        total_pnl: profitLoss,
        total_pnl_percent: profitLossPct,
      },
      summary: `Trade: ${profitLoss > 0 ? 'WIN' : 'LOSS'} - Entry: $${position.entry.toFixed(2)}, Exit: $${exitPrice.toFixed(2)}, P&L: $${profitLoss.toFixed(2)} (${profitLossPct.toFixed(2)}%)`,
    };

    console.log('');
    console.log('JSON_OUTPUT:');
    console.log(JSON.stringify(jsonOutput, null, 2));

  } else {
    console.log('='.repeat(60));
    console.log('‚ùå NO TRADE TAKEN');
    console.log('='.repeat(60));
  }
}

runORBBacktest().catch(console.error);
